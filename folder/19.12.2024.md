# Скрытие функционала базового класса

В производном классе может определить такую же функцию, как и родителя, но функция будет работать от производного класса и будет существовать вне зависимости базового класса

По сути производный класс скрывает функцию родителя. Однако иногда может потребоваться возможность вызвать реализацию функции, которая определена именно в базовом классе

```cpp
void print() const
{
    Person::print(); //Person - класс родитель
}
```

Также работает и с переменными

```cpp
Person::name;
```

Как логично додуматься, мы можем обращаться лишь к public и protected, к private обратиться мы никак не сможем

# Множественное наследование

Производный класс может иметь несколько прямых базовых классов (МАМА И ПАПА?! ЧТО). Подобный тип называется множественным, хоть и усложняется иерархия наследования, но как возможность имеется. Для каждого базового класса указывается тип передаваемый в производный

```cpp
class Smartphone : public Phone, public Camera   
{ };
```

Конструкторвы и деструкторы такого производного класса будут работать относительно того, как был создан производный

```cpp
class Ebook : public Book, public File 
{ };
```

То есть по сути сначало вызовется Book конструктор, а потом File и в окончании Ebook. При деструкторе сначало Ebook, File и в конце Book

Для конструктора производного класса в таком же порядке указываются классы

```cpp
class Ebook : public Book, public File 
{
Ebook(std::string title, unsigned pages, double size): 
        Book{pages}, File{size}, title{title}
}
```

Теперь есть проблема с "Скрытием функционала базового класса", так как теперь он у нас не один, а больше одного, так что код функции, который повторяется в базовых классах не будет сработан. Так что требуется конкретика, в плане указания самого класса и функции

```cpp
cppbook.Book::print(); //Book один из базовых классов
cppbook.File::print(); //File один из базовых классов
```

Еще одной формой двойственности при наследовании может быть наследование от нескольких классов, которые косвенно или напрямую наследуются от одного и того же класса. Например:

```cpp
class Student: public Person
{
public:
    Student(std::string name): Person{name} {}
};
class Employee: public Person
{
public:
    Employee(std::string name): Person{name} {}
};

class StudentEmployee: public Student, public Employee
{ };
```

То есть по сути упор на один класс от двух других классов. В данном случае два раза будут созданы конструкторы Person. Чтобы исправить данную проблему, используют virtual для изначального класса и теперь лишь раз создастся конструктор

```cpp
class Student: public virtual Person
{
public:
    Student(std::string name): Person{name} {}
};
class Employee: public virtual Person
{
public:
    Employee(std::string name): Person{name} {}
};
// работающий студент
class StudentEmployee: public Student, public Employee
{
```

# Виртуальные функции и их переопределение