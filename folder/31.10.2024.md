# Адрес указателя

```cpp
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a
```

# Можно проводить орпеации сравнения указателей с помощью следующих знаков: >, >=, <, <=,==, !=

# А это присвоение указателя одного типа значения к указателю другого типа

```cpp
#include <iostream>
 
int main()
{
    char c {'N'};
    char *pc {&c};            // указатель на символ
    int *pd {(int *)pc};      // указатель на int
    void *pv {(void*)pc};     // указатель на void
    std::cout << "pv=" << pv << std::endl;
    std::cout << "pd=" << pd << std::endl;
}
```

# Как собирать проект 
g++ main.cpp logger.cpp -o my_program //main.cpp and logger.cpp как две программы, их может быть больше или меньше
g++ *.cpp -o my_program //ищет все файлы с расширением .cpp

# Арифметика указателей 

По поводу указателей можно делать ++ и --. Но это будет прыжок не на один, а на следующий объект

А если будет что-то по примеру:
pd = pd + 2 //Это будет переход на второй объект после pd

```cpp
    double d {10.6};
    double *pd {&d};
    std::cout << "Pointer pd: address:" << pd << std::endl; //Pointer pd: address:0x2731bffd58
    pd++;   // увеличение адреса на 8 байт - размер double
    std::cout << "Pointer pd: address:" << pd << std::endl; //Pointer pd: address:0x2731bffd60
```

Можно делать разницу указателей. И разница между ними будет указывать на разницу в объектах

```cpp
    int *pa {&a}; //pa: 0x6258fffab4
    int *pb {&b}; //pb: 0x6258fffab0
    auto ab {pa - pb}; //ab: 1
```

# Указатели и массивы 

Если брать указатель на массив, то указатель будет указывать на первый объект массива

```cpp
#include <iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    std::cout << "nums[0] address: " << nums << std::endl; //nums[0] address: 0x1f1ebffe60
    std::cout << "nums[0] value: " << *nums << std::endl; //nums[0] value: 1
}
```

Используя сложение или вычитание, мы будем получать предыдущий или же следующий элемент массива. Можно удостовериться на циклах по перечислению элементов массива, но мы не можем изменять адрес

```cpp
#include <iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    for(unsigned i; i < std::size(nums); i++)
    {
        std::cout << "nums[" << i << "]: address=" << nums+i << "\tvalue=" << *(nums+i) << std::endl; //к nums прибавляют по i, которая перекидывает на объект
    }
}
```

# Указатель на строки и массивы символов

При работе с char массивов такая же система работает. То есть указатель массива указывает на первый объект, НО для вывода адреса требуется это:

```cpp
(void*)phello;    // 0x60fe8e первого элемента
```

# Массивы указателей 

Можно хранить определенные элементы в более меньшей по весу массиве, в отличии от обычных массивов. Как пример

```cpp
#include <iostream>
    
int main()
{
    const char *langs[] { "C++", "Python", "JavaScript"}; //Имеем массив указателей, где мы не указываем какой длины должен быть элемент
    // перебор массива
    for(unsigned i; i< std::size(langs); i++)
    {
        std::cout << langs[i] << std::endl;
    }
}
```

А в ином бы случае мы могли бы выделять 20 байтов на "C++", что выглядит крайне много для такой задачи [Выделяем 20 байтов из-за того, что мы обеспокоены большими элементами, как например "JavaScript"]
Через указатели, данные строки находятся в памяти, но такой же "C++" будет весить 4 байта

С одной стороны, мы здесь сталкиваемся с дополнительными издержками: дополнительно выделяется память для хранения адресов в указателях. С другой стороны, когда строки в массиве сильно различаются по длине , то мы можем получить общий выигрыш в количестве потребляемой памяти.