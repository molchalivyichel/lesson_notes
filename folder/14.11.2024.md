# Константные объекты и функции

Мы можем обозначит класс, как const. То есть мы сможем получать данные, но не изменять их (Понятное дело, только публичные)

Но вот незадача, мы потеряли доступ к функциям, так как по сути через функции могут меняться поля, что компилятор категорически не смеет предоставить. Так что для этого ставим const у функции (И логично, что функция поле не изменит, так как будет ошибка)

```cpp
void print() const {cout << name << endl;}
```

Вот и ещё ограничение, const-функции могут вызывать только const-функции (Если требуется вовсе) и понятное дело это ради того, чтобы ненароком изменить поле

# Возвращение констант

Еще одно ограничение, связанное с константными функциями, состоит в том, что, если мы хотим возвратить из константной функции указатель или ссылку, то они указетель должен указывать на константу, а ссылка должна быть константной

```cpp
    // возвращаем константную ссылку => main => string name = tom.getName();
    const std::string& getName() const
    {
        return name;
    }
    // возвращаем указатель на константу => main => const unsigned* age = tom.getAge();
    const unsigned* getAge() const
    {
        return &age;
    }
```

# mutable 

Иногда бывает необходимо, чтобы какие-то данные константного объекта все-таки можно было менять. В этом случае для переменной, которую необходимо менять, можно использовать ключевое слово mutable. И даже если объект является константным, значение такой переменной можно изменить.

```cpp
mutable unsigned age;

main()
{
    const Person tom{"Tom", 38};
    tom.age = 22;
}
```

---

# This...IS...FUCK lol. Ключевое слово this

Ключевое слово this представляет указатель на текущий объект данного класса и с попомщью него можем обращаться к полям класса.
После this ставится ->
Это не обязательно втыкать везде, можно лишь где-то ради удобства, например

```cpp
    Point(int x, int y) //конструктор
    {
        this->x = x; 
        this->y = y;
    }

    Point &move(int x, int y) //Функция, возвращающая себя же
    {
        this->x += x;
        this->y += y;
        return *this;
    }

    Point* movee(int x, int y) //Функция, возвращающая себя же
    {
        this->x += x;
        this->y += y;
        return this;
    }

    int main()
    {
        Point p1{20,50};
        p1.move(10,5).move(20,3); //Да-да, можно такое делать
        p1.movee(10, 5)->movee(10, 10)->movee(10, 15); //Или такую штуковину, на свой вкус и цвет
    }
```

---

# Дружественные функции и классы