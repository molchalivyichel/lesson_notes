# Константные объекты и функции

Мы можем обозначит класс, как const. То есть мы сможем получать данные, но не изменять их (Понятное дело, только публичные)

Но вот незадача, мы потеряли доступ к функциям, так как по сути через функции могут меняться поля, что компилятор категорически не смеет предоставить. Так что для этого ставим const у функции (И логично, что функция поле не изменит, так как будет ошибка)

```cpp
void print() const {cout << name << endl;}
```

Вот и ещё ограничение, const-функции могут вызывать только const-функции (Если требуется вовсе) и понятное дело это ради того, чтобы ненароком изменить поле

# Возвращение констант

Еще одно ограничение, связанное с константными функциями, состоит в том, что, если мы хотим возвратить из константной функции указатель или ссылку, то они указетель должен указывать на константу, а ссылка должна быть константной

```cpp
    // возвращаем константную ссылку => main => string name = tom.getName();
    const std::string& getName() const
    {
        return name;
    }
    // возвращаем указатель на константу => main => const unsigned* age = tom.getAge();
    const unsigned* getAge() const
    {
        return &age;
    }
```

# mutable 

Иногда бывает необходимо, чтобы какие-то данные константного объекта все-таки можно было менять. В этом случае для переменной, которую необходимо менять, можно использовать ключевое слово mutable. И даже если объект является константным, значение такой переменной можно изменить.

```cpp
mutable unsigned age;

main()
{
    const Person tom{"Tom", 38};
    tom.age = 22;
}
```

# This...IS...FUCK lol

