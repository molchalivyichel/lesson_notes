# Smart-указатели. unique_ptr<T>

Это имитация ситандартных указателей: Они также содержат адрес и к адресу обращаться можно. НО главное их отличие от страндартных указателей состоит в том, что нам не надо беспокоиться об освобождении памяти с помощью delete или delete[]

Вся выделенная память будет освобождаться автоматически, если не потребуется 

Пример инициализации указателя: 

```cpp
unique_ptr<int> ptr;
unique_ptr<int> ptr = nullptr; //Аналогично 10 строке
unique_ptr<int> ptr = make_unique<int>(125);
```

# Получение стандартного указателя

Чтобы получить стандартный указатель применяется get();

```cpp
int* pointer = ptr.get(); //Получение адреса
*ptr; //Получение значения
*ptr = 254; //Изменение значения
```

# НО МЫ НЕ МОЖЕМ

Указать два существующихся указателя, которые указывают на один и тот же адрес

# Работа с массивами

Мы можем работать и с массивами

```cpp
int n = 5;
auto pnumber = make_unique<int[]>(n); //Создание массива
cout << pnumber[1] << endl; //Обращение ко второму элементу
```

Если требуется всё таки освободить память, то юзаем reset()

```cpp
ptr.reset(); //Уничтожаем просто 
ptr.reset(new int = 254); //Присвоение нового адреса и значения
```

---

# Shared_ptr<T>

Применяется для создания указателей на объекты, на которые может указывать несколько указателей. Данный указатель позволяет создавать множество объектов shared_ptr<T>, которые содержат один и тот же адрес

Система данного указателя работает с помощью счетчика ссылок [При добавлении объекта +1, при изменении адреса или удаления объекта -1]

# Инициализация указателя

```cpp
shared_ptr<int> ptr;
shared_ptr<int> ptr; = make_shared<int>(22);
```

Для получения адреса не требуется get()

```cpp
ptr //Адрес
*ptr //Значение

shared_ptr<int> ptr2 = ptr; //адрес и значение одинаковы между ptr и ptr2
```

# Работа с массивами

```cpp
int n = 5;
auto pnumber = make_shared<int[]>(n);
```

---

# ООП - Объектно-ориентированное программирование

При обращении к переменной класса (полю) используем

```cpp
Person person;
person.name;

//При указателе класса по-другому обращаются к полям и функциям класса
Person* ptr = &person;
ptr -> name = "Tom";
ptr -> age = 25;
ptr -> print(); 
```