# Статические члены класса

static - это переменные, которые являются переменными для всех объектов данного класса (Как пример, что-то хранить, например количество созданных объектов). 

То есть когда при создании прибавляется к переменной +1, то это значит, что следующий класс будет иметь число на 1 больше, чем предыдущий

Бывают и функции и константы такие же, которые обычно работают между собой

---

# Деструктор класса

```cpp
~имя_класса() 
{
    // код деструктора
}
```

Деструктор класса - это момент удаления класса. Используется для удаления динамических переменных aka new. Может оповещения и других интересных концепций. Вызывается один раз, можно не приписывать к классу, тогда он будет создан автоматически

---

# Структуры 

Ммм.....................................................................................................................................................
Что могу сказать по поводу структур? В целом не особо чем-то отличается, кроме 

```cpp
struct MyStruct {
    int x; // public по умолчанию
};

class MyClass {
    int x; // private по умолчанию
};
```

---

Как говорят использовать для простых объектов, где важны только данные (Например vector или point, где имеются только координаты)

# Перечисления (enum)

Перечисления (enum) представляют еще один способ определения своих типов. Их отличительной особенностью является то, что они содержат набор числовых констант. Перечисление имеет следующую форму:

```cpp
enum class имя_перечисления { константа_1, константа_2, ... константа_N};
```

Используется, когда имеются ограниченные состояния и всё.

---

# Наследование

Наследование (inheritance) представляет один из ключевых аспектов объектно-ориентированного программирования, который позволяет наследовать функциональность одного класса (базового класса) в другом - производном классе (derived class).

Когда мы имеем человека, но нам требуется некоторое ветвление, например как "Сотрудник", мы можем сделать Человека родителем к Сотруднику. 
Да, конечно же мы можем написать два независимых класса, но смысл, если в "Сотруднике" практически такие же переменные (Например имя и возраст), но не хватает лишь компании

Чтобы объявить наследование, создаем класс и к классу прикладываем родителя. К сожалению к приватному доступ закрыт, хоть если и объявить private Person, он лишь сделает публичные и протектед модификации приватными для Employee (Что может пригодиться, если не нужно продолжать наследование)

```cpp
class Person
{
public:
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    std::string name;       //  имя
    unsigned age;           // возраст
};
class Employee : public Person
{
public:
    std::string company;    // компания
};
```

---

Конструкторы при наследовании не наследуются. И если базовый класс содержит только конструкторы с параметрами, то производный класс должен вызывать в своем конструкторе один из конструкторов базового класса:

```cpp
public:
    Employee(std::string name, unsigned age, std::string company): Person(name, age), company(company)
    {
        this->company = company;
    }
private:
    std::string company;    // компания
};
```

Можно вовсе подключить базовый конструктор основного класса, используя

```cpp
using Person::Person;   // подключаем конструктор базового класса
```

С конструктором копирования, та же история

```cpp
    Person(const Person& person)
    {
        name = person.name;
        age = person.age;
    }
//---
// вызываем конструктор копирования базового класса
    Employee(const Employee& employee): Person(employee)
    { 
        company=employee.company;
    }
```

Имеются же у нас и деструкторы, которые будут срабатывать и класса-наследника и класса-родителя. Как пример порядка срабатывания деструктора

```cs
Person created
Employee created
Name: Tom       Age: 38
Employee deleted
Person deleted
```

Можем вовсе запретить наследование с помощтью спецификатора final

```cpp
class Person final
{

};
```