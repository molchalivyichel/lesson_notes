# Разделение программы на файлы

Да, об этом частично затрагивалась тема в [Тык сюда](31.10.2024.md) - 29 строка

Так вот, образовывается вопрос по поводу запуска проекта. Да, мы может отказаться от этих заголовочных файлов, но какой ценой?

Мы уже знаем, что такое прототипы, а именно: 

```cpp
string startChat_custom(string);

int main()
{
    //code
}
```

То есть мы говорим компилятору о том, что у нас есть функция, доверься нам. И он нам верит! Но чтобы наш запускающийся файл (Например main.cpp) не был засран этими прототипами (Так как при большем проекте и больше функций) используют файлы с расширением .h

И вторая причина - это при изменении функции придется изменять используемую функцию (Прототип) в каждом исполняющем файле... Зачем, если у нас есть заголовочный файл!

# Внешние объекты

Можно создать внешние переменные за исполняющий файл

```cpp => obj.cpp
#include <iostream>
using namespace std;

extern bool check = false;
extern string message = "Hi! Nice to meet you, my future friend";
```

```cpp => obj.h
#include <iostream>
using namespace std;

extern bool check;
extern string message;
```

```cpp => main.cpp
extern bool check;
extern string message;
```

Даа, вот такой микро микро код получился. С помощью внешних объектов мы можем их вызывать в любом файле и использовать их. Хоть и компилятор предупреждает нас об этом, возможно из-за того, что может есть тяжесть управления такими переменными

# Динамические объекты

Использование динамических объектов имеет ряд преимуществ. Во-первых, более эффективное использование памяти - выделяется имеенно столько места, сколько необходимо, а после использования сразу освобождается. Во-вторых, мы можем использовать гораздо больший объем памяти, который в ином случае был бы не доступен. Но это и накладывает ограничения: мы должны следить, чтобы все динамические объекты были удалены (Даже если вы думаете, что он временный в блоке кода)

Есть new / delete 

```cpp
int *ptr = new int;
//---------
int *ptr = new int(5);
```

Чтобы удалять надо так и чтобы он не оставался бы "болтающим указателем" мы должны присвоить к нему следующее, чтобы при попытке вызова завершила программа (А не рандомный результат)

```cpp
delete ptr;
ptr = nullptr;
```

# Динамические массивы